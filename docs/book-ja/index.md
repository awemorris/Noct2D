# はじめに

本書をお手に取っていただきありがとうございます。本書は、PicoPicoScript（ピコスク）というプログラミング言語を使って、ゲームプログラミングを学ぼう、という書籍です。読者は小学校高学年以上を想定しています。

どんなプログラミング言語を最初に学ぶかということは、いつの時代にも大きな悩みの種ですよね。特に２０２０年代には、Ruby, Python, JavaScript など、魅力的な言語がいくつもあります。そんな中で、新規に一から開発されたピコスクには、実際の若年者へのプログラミング教育で便利なように、次のような利点が詰め込まれています。

- サイズが小さく、環境構築を即座に終えられる
- 文法学習に長い時間を割かなくてすむ
- 主流の言語と似た文法である
- 絵や音を簡単に出せる
- 作った作品をスマートフォンやタブレットに転送して動かせる
- 作った作品をZIPで他の人に配布できる

ピコスクは、名前はちょっとゆるいのですが、技術的には最先端かつ王道のものです。ピコスクで覚えたことは、他のプログラミング言語でもそのまま応用できますので、安心して学んでいただければと思います。また、スマートフォンやタブレットに作品を入れて、他の人に遊んでもらえるという点については、他の言語ではなかなか簡単には実現できないことですので、その点もぜひ楽しんでいただければと思います。

---

# まずは動かしてみよう

ここでは「ピコスクを手に入れて」「実行して」「ちょっとだけ自分で改造してみる」ところまでを体験します。
初めての人でもつまずかないように、一歩ずつ順番に進めていきましょう。

## ピコスクを手に入れる

ピコスクは無料で公開されています。公式ページ（GitHub）からダウンロードしましょう。

👉ダウンロード先
[https://github.com/awemorris/PicoPicoScript](https://github.com/awemorris/PicoPicoScript)

ダウンロードした ZIP ファイルを展開すると、いくつかのフォルダができます。
多くのユーザは Windows 11 を利用していると思いますので、ここでは Windows 11 を前提に進めます。

## 実行ファイルをみつける

展開したフォルダの中に windows-x86_64 というフォルダがあります。
その中に `picopico` というアイコンがあるはずです。
これががピコスク本体です。
（人によっては `picopico.exe` と表示されます。）

💡ヒント：`picopico` は、このファイル１つがあればそれだけで動きます。ほかの Windows PC にコピーしてもそのまま動作します。

## 動かしてみる

`picopico` をダブルクリックして動かしてみましょう。
正しく動作すれば、水色の箱がウィンドウの中を跳ね回る画面が出てきます。

「とりあえず動いた！」という瞬間です。ここまで来れば成功です！

## 初めての改造

次に、ちょっとした「魔法」をかけてみましょう。
`picopico` と同じフォルダにある `main.noct` というファイルをダブルクリックして、メモ帳で開いてください。そこにプログラムが書かれています。

その中に次の部分があります。

```
// Create a texture.
tex = Engine.createColorTexture({
    width: BLOCK_W,
    height: BLOCK_H,
    r: 0,
    g: 128,
    b: 255,
    a: 255
});
```

ここで、`r`, `g`, `b` が色の指定になっています。（赤＝Red、緑＝Green、青＝Blue）
数字はそれぞれの色の強さで、0 〜 255 の範囲で指定します。

試しに、次のように変えて保存してみましょう。

```
r: 255,
g: 0,
b: 0,
```

もう一度 `picopico` と実行すると……赤い箱が出てきましたね！

💡ヒント：コンピュータで色を指定するときには、RGB の３つの色の強さを使うことが一般的です。RGB のことを「光の三原色」といって、３つの色の光を組み合わせて、すべての色を表現することが可能です。

## まとめ

この章では：

- ピコスクを入手して動かす
- プログラムを少し書き換えて結果を確認する

までを体験しました。

次の章では、さらに自分のアイディアを形にする方法を学びます。

---

# プログラミングの基本

この章ではプログラミングの基本について説明します。

ピコスクは画面に絵を表示することに特化しているのですが、プログラミングの基本を勉強する上では、絵よりも文字を表示できることが大切です。そこで、この章ではピコスクの元となっている Noct 言語の実行ファイルを使います。

`picopico` と同じフォルダに `noct` というアイコンがあります。このファイルをダブルクリックすると、Noct 言語の黒い画面が起動します。ここにプログラムを入力して、基本を身に付けていきます。

## 足し算

黒い画面に、次の４行を入力してみてください。

```
a = 1
b = 2
c = a + b
print(a + b)
```

入力ミスがなければ、次のように表示されます。

```
3
```

---

# ピコスクのプログラムの構成

この章では、Noct 言語からステップアップして、ピコスクのプログラムの書き方を学びます。

多くのプログラミング言語では、関数（かんすう）と呼ばれる単位でプログラムを書きます。ピコスクでは、`setup`, `start`, `frame` の３つの関数を書くことで、ゲームを作ります。

`picopico` と同じフォルダに入っている `main.noct` を開いてみます。このプログラムを眺めてみると、`setup`, `start`, `frame` の３つの関数でできていることがわかると思います。

## setup 関数

`setup` 関数の中身を見てみると、次のようになっています。`func` というのが関数の定義の目印で、`function` つまり英語で関数の略です。

```
func setup() {
    return {
        width: 800,
        height: 450,
        title: "Bouncer"
    };
```

この `setup` 関数は、ピコスクの起動時に一度だけ実行されるものです。関数には呼び出し元、呼び出し先という考え方があり、この `setup` 関数の場合だと、ピコスクのシステムが呼び出し元で、`setup` 関数が呼び出し先になります。`setup` 関数は呼び出されると、呼び出し元であるピコスクのシステムに対して、ゲームの設定を返します。

設定というのは、画面表示に関わる重要な決めごとのことです。ここでは、プログラムの画面表示を 800×450 というサイズで行うことと、ウィンドウの名前を `Bouncer` にするという決めごとを行っています。

## start 関数

次に出てくる `start` という関数は、ピコスクがプログラムに準備を行ってほしいときに１回だけ呼び出されます。ここでは、色のついた箱の画像を作る処理を行っています。

```
func start() {
    W = 800;
    H = 450;
    BLOCK_W = 48;      // pixels
    BLOCK_H = 48;      // pixels
    SPEED_X = 180.0;   // pixels/sec
    SPEED_Y = 140.0;   // pixels/sec
    MAX_DT  = 0.1;     // sec

    // Create a texture.
    tex = Engine.createColorTexture({
        width: BLOCK_W,
        height: BLOCK_H,
        r: 0,
        g: 128,
        b: 255,
        a: 255
    });

    // Set the initial block position.
    x = (W - BLOCK_W) * 0.5;
    y = (H - BLOCK_H) * 0.5;

    // Set the initial speed.
    vx = SPEED_X;
    vy = SPEED_Y;

    last_ms = Engine.millisec;
}
```

## frame 関数

最後に出てくる `frame` という関数は、１秒間に６０回、画面を書き換えるたびに呼び出されるものです。ここでは、箱の移動と描画（画面に絵を描くこと）を行っています。

```
func frame() {
    var now_ms = Engine.millisec;
    var dt = (now_ms - last_ms) * 0.001;
    last_ms = now_ms;

    // Process the input.
    if (Engine.isMouseLeftPressed) {
        x = (W - BLOCK_W) * 0.5;
        y = (H - BLOCK_H) * 0.5;
    }

    // Update the position
    x = x + vx * dt;
    y = y + vy * dt;

    // Reflect.
    if (x < 0) {
        // Left to right.
        x = -x;
        vx = -vx;
    } else if (x > W - BLOCK_W) {
        // Right to left.
        x = 2*(W - BLOCK_W) - x;
        vx = -vx;
    }
    if (y < 0) {
        // Up to down.
        y = -y;
        vy = -vy;
    } else if (y > H - BLOCK_H) {
        // Down to up.
        y = 2*(H - BLOCK_H) - y;
        vy = -vy;
    }

    // Draw.
    Engine.draw({
        texture: tex,
        x: x,
        y: y
    });
}
```
