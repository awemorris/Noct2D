func newNovel() {
    var novel = {
        //
        // Current tag function.
        //

        curTagFunc: 0,

        //
        // Layer Index
        //
        LAYER_BG:           0,
        LAYER_BG_FI:        1,

        //
        // Layer Count
        //
	STAGE_LAYERS:      74,

        //
        // Character Layer Count
        //
        CH_LAYERS:          8,

        //
        // Text Layer Count
        //
        TEXT_LAYERS:        8,

        //
        // Effect Layer Count
        //
        EF_LAYERS:          8,

        //
        // Selection Layer Count
        //
        SEL_LAYERS:         8,
        //
        // Click Animation Frames
        //
        CLICK_FRAMES:      16,

        //
        // Effect Method
        //
        FADE_NORMAL:        0,
        FADE_RULE:          1,
        FADE_MELT:          2,

        //
        // Stage Images
        //

        layerTex:   0,
        msgboxTex:  0,
        nameboxTex: 0,
        clickText:  0,

        //
        // Layer Properties
        //
        layerFile:    0,  // The file names of the layers.
        layerX:       0,  // The X positions of the layers.
        layerY:       0,  // The Y positions of the layers.
        layerAlpha:   0,  // The alpha values of the layers.
        layerScaleX:  0,  // The X-scale of the layers.
        layerScaleY:  0,  // The Y-Scale of the layers.
        layerCenterX: 0,  // The X-center of the layers.
        layerCenterY: 0,  // The Y-center of the layers.
        layerRotate:  0,  // The rotation of the layers.

        //
        // Initialization
        //

        // Initialize the novel object.
        init: (this) => {
            Novel = this;

            this->initStage();
            this->initAnime();
        },

        // Initialize the stage.
        initStage: (this) => {
            this.layerTex = [];
            this.layerTex->resize(this.STAGE_LAYERS);

            this.layerFile = [];
            this.layerFile->resize(this.STAGE_LAYERS);

            this.layerX = [];
            this.layerX->resize(this.STAGE_LAYERS);

            this.layerY = [];
            this.layerY->resize(this.STAGE_LAYERS);

            this.layerAlpha = [];
            this.layerAlpha->resize(this.STAGE_LAYERS);
            
            this.layerSX = [];
            this.layerSX->resize(this.STAGE_LAYERS);

            this.layerSY = [];
            this.layerSY->resize(this.STAGE_LAYERS);

            this.layerCX = [];
            this.layerCX->resize(this.STAGE_LAYERS);

            this.layerCY = [];
            this.layerCY->resize(this.STAGE_LAYERS);

            this.layerRot = [];
            this.layerRot->resize(this.STAGE_LAYERS);

            this.layerFrame = [];
            this.layerFrame->resize(this.STAGE_LAYERS);

            // Initial background.
            //this.layerTex[0] = Engine.createColorTexture({width:1280, height:720, r:0, g:0, b:0, a:255});
            //this.layerAlpha[0] = 255;

            this.layerTex[0] = Engine.createColorTexture({width:1280, height:720, r:0, g:0, b:0, a:255});
            this.layerAlpha[0] = 255;
        },

        loadLayerImage: (this, layer, file) => {
            this.layerTex[layer] = Engine.loadTexture({file: file});
        },

        destroyLayerImage: (this, layer) => {
            Engine.destroyTexture({texture: this.layerTex[layer]});
            this.layerTex[layer] = 0;
        },

        swapLayerImage: (this, newLayer, oldLayer) => {
            if (this.layerTex[oldLayer] != 0) {
                this.destroyLayerImage(oldLayer);
            }

            this.layerTex[oldLayer]     = this.layerTex[newLayer];
            this.layerX[oldLayer]       = this.layerX[newLayer]; 
            this.layerY[oldLayer]       = this.layerY[newLayer]; 
            this.layerAlpha[oldLayer]   = this.layerAlpha[newLayer]; 
            this.layerScaleX[oldLayer]  = this.layerScaleX[newLayer]; 
            this.layerScaleY[oldLayer]  = this.layerScaleY[newLayer]; 
            this.layerCenterX[oldLayer] = this.layerCenterX[newLayer]; 
            this.layerCenterY[oldLayer] = this.layerCenterY[newLayer]; 
            this.layerRotate[oldLayer]  = this.layerRotate[newLayer]; 

            this.layerTex[newLayer] = 0;
        },

        setLayerPosition: (this, layer, x, y) => {
            this.layerX[layer] = x;
            this.layerY[layer] = y;
        },

        setLayerAlpha: (this, layer, alpha) => {
            this.layerAlpha[layer] = alpha;
        },

        startFade: (this) => {
            this.fadeStartTime = Engine.millisec;
        },

        //
        // Anime
        //

        SEQUENCE_COUNT: 1024,

        animeSequence: [],
        animeContext: [],

        initAnime: (this) => {
            for (i in 0 .. this.STAGE_LAYERS) {
                this.animeContext[i] = {
                    isRunning:  0,
                    isCompleted: 0,
                    startTime:  0,
                    curLap:     0
                };
            }
        },

        // Loads an anime descriptor.
        startAnime: (this, animeSeq) => {
            // The result array includes layer indices.
            var result = [];

            // Initialize the sequence arrays of the specified layers.
            for (seq in animeSeq) {
                this.animeSequence[seq.layer] = [];
                result.push(seq.layer);
            }

            // Add the sequences to the layer sequence arrays.
            for (seq in animeSeq) {
                // Default values.
                var s = {
                    startTime: 0,
                    endTime:   0,
                    fromX:     0,
                    fromY:     0,
                    fromAlpha:  0,
                    fromScaleX: 0,
                    fromScaleY: 0,
                    fromRotate: 0.0,
                    toX:        0,
                    toY:        0,
                    toAlpha:    0,
                    toScaleX:   1.0,
                    toScaleY:   1.0,
                    toRotate:   0.0,
                    centerX:    0,
                    centerY:    0
                };

                // Copy the sequence parameters.
                for (k, v in seq) {
                    if (k != "layer") {
                        s[k] = v;
                    }
                }

                // Add to the layer sequence array.
                this.animeSequence[seq.layer]->push(s);
            }

            // Set the layer anime contexts.
            for (seq in animeSeq) {
                this.animeContext[seq.layer].isRunning = 1;
                this.animeContext[seq.layer].isCompleted = 0;
                this.animeContext[seq.layer].startTime = Engine.millisec;
                this.animeContext[seq.layer].curLap = 0;
            }

            return result;
        },

        // Updates the parameters of stage layers using anime.
        updateAnime: (this) => {
            // Detect anime completions.
            for (i in 0 .. this.STAGE_LAYERS) {
                // Skip if the layer anime is not running or completed.
                if (!this.animeContext[i].isRunning ||
                    this.animeContext[i].isCompleted) {
                    continue;
                }

                // Get the lap.
                this.animeContext[i].curLap = Engine.millisec - this.animeContext[i].startTime;

                var lastSeq = animeSequence[i].length - 1;
                if (this.animeContext[i].curLap >= this.animeSequence[i][lastSeq].endTime) {
                    this.animeContext[i].isRunning = 0;
                    this.animeContext[i].isCompleted = 1;
                }
            }

            // Update the parameters for the stage layers.
            for (i in 0 .. this.STAGE_LAYERS) {
                // Skip if the anime sequence for the layer is empty.
                if (this.animeSequence.length == 0) {
                    continue;
                }

                // Prepare the parameters.
                var x = 0;
                var y = 0;
                var alpha = 0;
                var scaleX = 1.0;
                var scaleY = 1.0;
                var rotate = 1.0;

                // If already completed.
                if (this.animeContext[i].isCompleted &&
                    this.animeSequence[i].length > 0) {
                    var s = this.animeSequence[i][this.animeSeqence[i].length - 1];
                    this.layerX[i] = s.toX;
                    this.layerY[i] = s.toY;
                    this.layerAlpha[i] = s.toAlpha;
                    this.layerScaleX[i] = s.toScaleX;
                    this.layerScaleY[i] = s.toScaleY;
                    this.layerCenterX[i] = s.centerX;
                    this.layerCenterY[i] = s.centerY;
                    this.layerRotate[i] = s.toRotate * (3.14159265 / 180.0);
                    continue;
                }

                // Interpolate the parameters.
                for (j in 0 .. this.animeSequence[i].length) {
                    var s = this.animeSequence[i][j];
                    if (this.animeContext[i].curLap < s.startTime) {
                        continue;
                    }
                    if (j != this.animeSequence[i].length - 1 &&
                        this.animeContext[i].curLap > s.endTime) {
                        continue;
                    }

                    // Calculate the progress.
                    var progress = (this.animeContext[i].curLap - s.startTime) / (s.endTime - s.startTime);
                    if (progress > 1.0) {
                        progress = 1.0;
                    }

                    // Calculate the parameters.
                    this.layerX[i] = s.fromX + (s.toX - s.fromX) * progress;
                    this.layerY[i] = s.fromY + (s.toY - s.fromY) * progress;
                    this.layerAlpha[i] = s.fromAlpha + (s.toAlpha - s.fromAlpha) * progress;
                    this.layerScaleX[i] = s.fromScaleX + (s.toScaleX - s.fromScaleX) * progress;
                    this.layerScaleY[i] = s.fromScaleY + (s.toScaleY - s.fromScaleY) * progress;
                    this.layerCenterX[i] = s.centerX;
                    this.layerCenterY[i] = s.centerY;
                    this.layerRotate[i] = s.fromRotate + (s.toRotate - s.fromRotate) * progress * (3.14159265 / 180.0);
                    break;
                }
            }
        },

        isLayerAnimeCompleted: (this, layer) => {
            return this.animeContext[layer].isCompleted;
        },

        //
        // Scene
        //

        moveToTagFile: (this, file) => {
            Engine.moveToTagFile({file: file});
	    return 0;
        },

        moveToNextTag: (this) => {
            Engine.moveToNextTag({});
        },

        //
        // Rendering
        //

        // Frame renderer.
        frame: (this) => {
            if (this.curTagFunc == 0) {
                Engine.callTagFunction({});
            } else {
                this.curTagFunc({});
            }

            this->renderStage();

	    return 0;
        },

        // Renders the stage.
        renderStage: (this) => {
            for (i in 0..this.STAGE_LAYERS) {
                if (Novel.layerTex[i] != 0) {
                    Engine.renderTexture({
                        dstLeft:   this.layerX[i],
                        dstTop:    this.layerY[i],
                        dstWidth:  this.layerTex[i].width,
                        dstHeight: this.layerTex[i].height,
                        texture:   this.layerTex[i],
                        srcLeft:   0,
                        srcTop:    0,
                        srcWidth:  this.layerTex[i].width,
                        srcHeight: this.layerTex[i].height,
                        alpha:     this.layerAlpha[i]
                    });
                }
            }
        }
    };

    novel->init();

    return novel;
}

func Tag_background(param) {
    //
    // Initialize.
    //
    if (Novel.curTagFunc == 0) {
        Novel.curTagFunc = Tag_background;
        Novel.tagWorkspace = {};

        Novel->loadLayerImage(Novel.LAYER_BG_FI, param.file);

        Novel.tagWorkspace.animeLayers = Novel->startAnime([
            {
                layer:      Novel.LAYER_BG,
                startTime:  0.0,
                endTime:    1.0,
                fromAlpha:  255,
                toAlpha:    0
            },
            {
                layer:      Novel.LAYER_BG_FI,
                startTime:  0.0,
                endTime:    1.0,
                fromAlpha:  0,
                toAlpha:    255
            }
        ]);
    }

    //
    // Rendering.
    //
    Novel->renderStage();

    //
    // Completion.
    //
    var notCompleted = 0;
    for (layer in Novel.tagWorkspace.animeLayers) {
        if (!this.isLayerAnimeCompleted(layer)) {
            notCompleted = 1;
            break;
        }
    }
    if (!notCompleted) {
        Novel->swapLayerImage(Novel.LAYER_BG_FI, Novel.LAYER_BG);
        Novel->moveToNextTag();
    }

    return 1;
}

func Tag_click(param) {
    if (Novel.curTagFunc == 0) {
        Novel.curTagFunc = Tag_click;
    }

    if (Engine.isMouseLeftPressed) {
        Novel.curTagFunc = 0;
        Novel->moveToNextTag();
    }
        
    return 1;
}
